/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2015, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var arrays = require('phosphor-arrays');
var phosphor_boxengine_1 = require('phosphor-boxengine');
var phosphor_domutil_1 = require('phosphor-domutil');
var phosphor_messaging_1 = require('phosphor-messaging');
var phosphor_panel_1 = require('phosphor-panel');
var phosphor_properties_1 = require('phosphor-properties');
var phosphor_widget_1 = require('phosphor-widget');
/**
 * The class name added to hidden split handles.
 */
var HIDDEN_CLASS = 'p-mod-hidden';
/**
 * The class name added to horizontal split panels.
 */
var HORIZONTAL_CLASS = 'p-mod-horizontal';
/**
 * The class name added to vertical split panels.
 */
var VERTICAL_CLASS = 'p-mod-vertical';
/**
 * The orientation of a split layout.
 */
(function (Orientation) {
    /**
     * Left-to-right horizontal orientation.
     */
    Orientation[Orientation["Horizontal"] = 0] = "Horizontal";
    /**
     * Top-to-bottom vertical orientation.
     */
    Orientation[Orientation["Vertical"] = 1] = "Vertical";
})(exports.Orientation || (exports.Orientation = {}));
var Orientation = exports.Orientation;
/**
 * A layout which arranges its children into resizable sections.
 */
var SplitLayout = (function (_super) {
    __extends(SplitLayout, _super);
    /**
     * Construct a new split layout.
     *
     * @param factory - The handle factory for creating split handles.
     */
    function SplitLayout(factory) {
        _super.call(this);
        this._fixed = 0;
        this._spacing = 3;
        this._normed = false;
        this._box = null;
        this._sizers = [];
        this._handles = [];
        this._orientation = Orientation.Horizontal;
        this._factory = factory;
    }
    Object.defineProperty(SplitLayout.prototype, "orientation", {
        /**
         * Get the layout orientation for the split layout.
         */
        get: function () {
            return this._orientation;
        },
        /**
         * Set the layout orientation for the split layout.
         */
        set: function (value) {
            if (this._orientation === value) {
                return;
            }
            this._orientation = value;
            if (!this.parent) {
                return;
            }
            SplitLayoutPrivate.toggleOrientation(this.parent, value);
            this.parent.fit();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitLayout.prototype, "spacing", {
        /**
         * Get the inter-element spacing for the split layout.
         */
        get: function () {
            return this._spacing;
        },
        /**
         * Set the inter-element spacing for the split layout.
         */
        set: function (value) {
            value = Math.max(0, value | 0);
            if (this._spacing === value) {
                return;
            }
            this._spacing = value;
            if (!this.parent) {
                return;
            }
            this.parent.fit();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the normalized sizes of the widgets in the layout.
     *
     * @returns The normalized sizes of the widgets in the layout.
     */
    SplitLayout.prototype.sizes = function () {
        return SplitLayoutPrivate.normalize(this._sizers.map(function (s) { return s.size; }));
    };
    /**
     * Set the relative sizes for the child widgets in the layout.
     *
     * @param sizes - The relative sizes for the children in the layout.
     *   These values will be normalized to the available layout space.
     *
     * #### Notes
     * Extra values are ignored, too few will yield an undefined layout.
     */
    SplitLayout.prototype.setSizes = function (sizes) {
        var normed = SplitLayoutPrivate.normalize(sizes);
        for (var i = 0, n = this._sizers.length; i < n; ++i) {
            var hint = Math.max(0, normed[i] || 0);
            var sizer = this._sizers[i];
            sizer.sizeHint = hint;
            sizer.size = hint;
        }
        this._normed = true;
        if (this.parent)
            this.parent.update();
    };
    /**
     * Get the handle for the widget at the given index.
     *
     * @param index - The index of the handle of interest.
     *
     * @returns The handle for the given index, or `undefined`.
     */
    SplitLayout.prototype.handleAt = function (index) {
        return this._handles[index];
    };
    /**
     * Move a split handle to the specified offset position.
     *
     * @param index - The index of the handle of the interest.
     *
     * @param position - The desired offset position of the handle. This
     *   is the absolute position relative to the origin of the parent.
     *
     * #### Notes
     * This will move the handle as close as possible to the desired
     * position. The sibling children will be adjusted as necessary.
     */
    SplitLayout.prototype.moveHandle = function (index, position) {
        // Bail if the index is invalid or the handle is hidden.
        var handle = this._handles[index];
        if (!handle || handle.classList.contains(HIDDEN_CLASS)) {
            return;
        }
        // Compute the delta movement for the handle.
        var delta;
        if (this._orientation === Orientation.Horizontal) {
            delta = position - handle.offsetLeft;
        }
        else {
            delta = position - handle.offsetTop;
        }
        // Bail if there is no handle movement.
        if (delta === 0) {
            return;
        }
        // Prevent item resizing unless needed.
        for (var _i = 0, _a = this._sizers; _i < _a.length; _i++) {
            var sizer = _a[_i];
            if (sizer.size > 0)
                sizer.sizeHint = sizer.size;
        }
        // Adjust the sizers to reflect the movement.
        if (delta > 0) {
            SplitLayoutPrivate.growSizer(this._sizers, index, delta);
        }
        else {
            SplitLayoutPrivate.shrinkSizer(this._sizers, index, -delta);
        }
        // Update the layout of the child widgets.
        if (this.parent)
            this.parent.update();
    };
    /**
     * Initialize the children of the layout.
     *
     * #### Notes
     * This method is called automatically when the layout is installed
     * on its parent widget.
     */
    SplitLayout.prototype.initialize = function () {
        SplitLayoutPrivate.toggleOrientation(this.parent, this.orientation);
        _super.prototype.initialize.call(this);
    };
    /**
     * Attach a child widget to the parent's DOM node.
     *
     * @param index - The current index of the child in the layout.
     *
     * @param child - The child widget to attach to the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    SplitLayout.prototype.attachChild = function (index, child) {
        var handle = SplitLayoutPrivate.createHandle(this._factory);
        var average = SplitLayoutPrivate.averageSize(this._sizers);
        var sizer = SplitLayoutPrivate.createSizer(average);
        arrays.insert(this._sizers, index, sizer);
        arrays.insert(this._handles, index, handle);
        SplitLayoutPrivate.prepareGeometry(child);
        this.parent.node.appendChild(child.node);
        this.parent.node.appendChild(handle);
        if (this.parent.isAttached)
            phosphor_messaging_1.sendMessage(child, phosphor_widget_1.Widget.MsgAfterAttach);
        this.parent.fit();
    };
    /**
     * Move a child widget in the parent's DOM node.
     *
     * @param fromIndex - The previous index of the child in the layout.
     *
     * @param toIndex - The current index of the child in the layout.
     *
     * @param child - The child widget to move in the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    SplitLayout.prototype.moveChild = function (fromIndex, toIndex, child) {
        arrays.move(this._sizers, fromIndex, toIndex);
        arrays.move(this._handles, fromIndex, toIndex);
        this.parent.fit(); // fit instead of update to show/hide handles
    };
    /**
     * Detach a child widget from the parent's DOM node.
     *
     * @param index - The previous index of the child in the layout.
     *
     * @param child - The child widget to detach from the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    SplitLayout.prototype.detachChild = function (index, child) {
        var sizer = arrays.removeAt(this._sizers, index);
        var handle = arrays.removeAt(this._handles, index);
        if (this.parent.isAttached)
            phosphor_messaging_1.sendMessage(child, phosphor_widget_1.Widget.MsgBeforeDetach);
        this.parent.node.removeChild(child.node);
        this.parent.node.removeChild(handle);
        SplitLayoutPrivate.resetGeometry(child);
        this.parent.fit();
    };
    /**
     * A message handler invoked on an `'after-show'` message.
     */
    SplitLayout.prototype.onAfterShow = function (msg) {
        _super.prototype.onAfterShow.call(this, msg);
        this.parent.update();
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    SplitLayout.prototype.onAfterAttach = function (msg) {
        _super.prototype.onAfterAttach.call(this, msg);
        this.parent.fit();
    };
    /**
     * A message handler invoked on a `'child-shown'` message.
     */
    SplitLayout.prototype.onChildShown = function (msg) {
        if (SplitLayoutPrivate.IsIE) {
            phosphor_messaging_1.sendMessage(this.parent, phosphor_widget_1.Widget.MsgFitRequest);
        }
        else {
            this.parent.fit();
        }
    };
    /**
     * A message handler invoked on a `'child-hidden'` message.
     */
    SplitLayout.prototype.onChildHidden = function (msg) {
        if (SplitLayoutPrivate.IsIE) {
            phosphor_messaging_1.sendMessage(this.parent, phosphor_widget_1.Widget.MsgFitRequest);
        }
        else {
            this.parent.fit();
        }
    };
    /**
     * A message handler invoked on a `'resize'` message.
     */
    SplitLayout.prototype.onResize = function (msg) {
        if (this.parent.isVisible) {
            this._update(msg.width, msg.height);
        }
    };
    /**
     * A message handler invoked on an `'update-request'` message.
     */
    SplitLayout.prototype.onUpdateRequest = function (msg) {
        if (this.parent.isVisible) {
            this._update(-1, -1);
        }
    };
    /**
     * A message handler invoked on a `'fit-request'` message.
     */
    SplitLayout.prototype.onFitRequest = function (msg) {
        if (this.parent.isAttached) {
            this._fit();
        }
    };
    /**
     * Fit the layout to the total size required by the child widgets.
     */
    SplitLayout.prototype._fit = function () {
        // Update the handles and track the visible widget count.
        var nVisible = 0;
        var lastHandle = null;
        for (var i = 0, n = this.childCount(); i < n; ++i) {
            var handle = this._handles[i];
            if (this.childAt(i).isHidden) {
                handle.classList.add(HIDDEN_CLASS);
            }
            else {
                handle.classList.remove(HIDDEN_CLASS);
                lastHandle = handle;
                nVisible++;
            }
        }
        // Hide the handle for the last visible child.
        if (lastHandle)
            lastHandle.classList.add(HIDDEN_CLASS);
        // Update the fixed space for the visible items.
        this._fixed = this._spacing * Math.max(0, nVisible - 1);
        // Setup the initial size limits.
        var minW = 0;
        var minH = 0;
        var maxW = Infinity;
        var maxH = Infinity;
        var horz = this._orientation === Orientation.Horizontal;
        if (horz) {
            minW = this._fixed;
            maxW = nVisible > 0 ? minW : maxW;
        }
        else {
            minH = this._fixed;
            maxH = nVisible > 0 ? minH : maxH;
        }
        // Update the sizers and computed size limits.
        for (var i = 0, n = this.childCount(); i < n; ++i) {
            var child = this.childAt(i);
            var sizer = this._sizers[i];
            if (sizer.size > 0) {
                sizer.sizeHint = sizer.size;
            }
            if (child.isHidden) {
                sizer.minSize = 0;
                sizer.maxSize = 0;
                continue;
            }
            var limits = phosphor_domutil_1.sizeLimits(child.node);
            sizer.stretch = SplitLayout.getStretch(child);
            if (horz) {
                sizer.minSize = limits.minWidth;
                sizer.maxSize = limits.maxWidth;
                minW += limits.minWidth;
                maxW += limits.maxWidth;
                minH = Math.max(minH, limits.minHeight);
                maxH = Math.min(maxH, limits.maxHeight);
            }
            else {
                sizer.minSize = limits.minHeight;
                sizer.maxSize = limits.maxHeight;
                minH += limits.minHeight;
                maxH += limits.maxHeight;
                minW = Math.max(minW, limits.minWidth);
                maxW = Math.min(maxW, limits.maxWidth);
            }
        }
        // Update the box sizing and add it to the size constraints.
        var box = this._box = phosphor_domutil_1.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        maxW += box.horizontalSum;
        maxH += box.verticalSum;
        // Update the parent's size constraints.
        var style = this.parent.node.style;
        style.minWidth = minW + "px";
        style.minHeight = minH + "px";
        style.maxWidth = maxW === Infinity ? 'none' : maxW + "px";
        style.maxHeight = maxH === Infinity ? 'none' : maxH + "px";
        // Notify the ancestor that it should fit immediately.
        var ancestor = this.parent.parent;
        if (ancestor)
            phosphor_messaging_1.sendMessage(ancestor, phosphor_widget_1.Widget.MsgFitRequest);
        // Notify the parent that it should update immediately.
        phosphor_messaging_1.sendMessage(this.parent, phosphor_widget_1.Widget.MsgUpdateRequest);
    };
    /**
     * Update the layout position and size of the child widgets.
     *
     * The parent offset dimensions should be `-1` if unknown.
     */
    SplitLayout.prototype._update = function (offsetWidth, offsetHeight) {
        // Bail early if there are no children to layout.
        if (this.childCount() === 0) {
            return;
        }
        // Measure the parent if the offset dimensions are unknown.
        if (offsetWidth < 0) {
            offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
            offsetHeight = this.parent.node.offsetHeight;
        }
        // Ensure the parent box sizing data is computed.
        var box = this._box || (this._box = phosphor_domutil_1.boxSizing(this.parent.node));
        // Compute the actual layout bounds adjusted for border and padding.
        var top = box.paddingTop;
        var left = box.paddingLeft;
        var width = offsetWidth - box.horizontalSum;
        var height = offsetHeight - box.verticalSum;
        // Compute the adjusted layout space.
        var space;
        var horz = this._orientation === Orientation.Horizontal;
        if (horz) {
            space = Math.max(0, width - this._fixed);
        }
        else {
            space = Math.max(0, height - this._fixed);
        }
        // Scale the size hints if they are normalized.
        if (this._normed) {
            for (var _i = 0, _a = this._sizers; _i < _a.length; _i++) {
                var sizer = _a[_i];
                sizer.sizeHint *= space;
            }
            this._normed = false;
        }
        // Distribute the layout space to the box sizers.
        phosphor_boxengine_1.boxCalc(this._sizers, space);
        // Layout the children using the computed box sizes.
        var spacing = this._spacing;
        for (var i = 0, n = this.childCount(); i < n; ++i) {
            var child = this.childAt(i);
            if (child.isHidden) {
                continue;
            }
            var handle = this._handles[i];
            var size = this._sizers[i].size;
            if (horz) {
                SplitLayoutPrivate.setGeometry(child, left, top, size, height);
                left += size;
                SplitLayoutPrivate.setHandleGeo(handle, left, top, spacing, height);
                left += spacing;
            }
            else {
                SplitLayoutPrivate.setGeometry(child, left, top, width, size);
                top += size;
                SplitLayoutPrivate.setHandleGeo(handle, left, top, width, spacing);
                top += spacing;
            }
        }
    };
    return SplitLayout;
})(phosphor_panel_1.PanelLayout);
exports.SplitLayout = SplitLayout;
/**
 * The namespace for the `SplitLayout` class statics.
 */
var SplitLayout;
(function (SplitLayout) {
    /**
     * A convenience alias of the `Horizontal` [[Orientation]].
     */
    SplitLayout.Horizontal = Orientation.Horizontal;
    /**
     * A convenience alias of the `Vertical` [[Orientation]].
     */
    SplitLayout.Vertical = Orientation.Vertical;
    /**
     * Get the split layout stretch factor for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @returns The split layout stretch factor for the widget.
     */
    function getStretch(widget) {
        return SplitLayoutPrivate.stretchProperty.get(widget);
    }
    SplitLayout.getStretch = getStretch;
    /**
     * Set the split layout stretch factor for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @param value - The value for the stretch factor.
     */
    function setStretch(widget, value) {
        SplitLayoutPrivate.stretchProperty.set(widget, value);
    }
    SplitLayout.setStretch = setStretch;
})(SplitLayout = exports.SplitLayout || (exports.SplitLayout = {}));
/**
 * The namespace for the `SplitLayout` class private data.
 */
var SplitLayoutPrivate;
(function (SplitLayoutPrivate) {
    /**
     * A flag indicating whether the browser is IE.
     */
    SplitLayoutPrivate.IsIE = /Trident/.test(navigator.userAgent);
    /**
     * The property descriptor for a widget stretch factor.
     */
    SplitLayoutPrivate.stretchProperty = new phosphor_properties_1.Property({
        name: 'stretch',
        value: 0,
        coerce: function (owner, value) { return Math.max(0, value | 0); },
        changed: onChildPropertyChanged,
    });
    /**
     * Create a new box sizer with the given size hint.
     */
    function createSizer(size) {
        var sizer = new phosphor_boxengine_1.BoxSizer();
        sizer.sizeHint = size | 0;
        return sizer;
    }
    SplitLayoutPrivate.createSizer = createSizer;
    /**
     * Create a new split handle using the given factory.
     */
    function createHandle(factory) {
        var handle = factory.createHandle();
        handle.style.position = 'absolute';
        return handle;
    }
    SplitLayoutPrivate.createHandle = createHandle;
    /**
     * Toggle the CSS orientation class for the given widget.
     */
    function toggleOrientation(widget, orient) {
        widget.toggleClass(HORIZONTAL_CLASS, orient === Orientation.Horizontal);
        widget.toggleClass(VERTICAL_CLASS, orient === Orientation.Vertical);
    }
    SplitLayoutPrivate.toggleOrientation = toggleOrientation;
    /**
     * Prepare the layout geometry for the given child widget.
     */
    function prepareGeometry(widget) {
        widget.node.style.position = 'absolute';
    }
    SplitLayoutPrivate.prepareGeometry = prepareGeometry;
    /**
     * Reset the layout geometry for the given child widget.
     */
    function resetGeometry(widget) {
        var rect = rectProperty.get(widget);
        var style = widget.node.style;
        rect.top = NaN;
        rect.left = NaN;
        rect.width = NaN;
        rect.height = NaN;
        style.position = '';
        style.top = '';
        style.left = '';
        style.width = '';
        style.height = '';
    }
    SplitLayoutPrivate.resetGeometry = resetGeometry;
    /**
     * Set the layout geometry of a child widget.
     */
    function setGeometry(widget, left, top, width, height) {
        var resized = false;
        var style = widget.node.style;
        var rect = rectProperty.get(widget);
        if (rect.top !== top) {
            rect.top = top;
            style.top = top + "px";
        }
        if (rect.left !== left) {
            rect.left = left;
            style.left = left + "px";
        }
        if (rect.width !== width) {
            resized = true;
            rect.width = width;
            style.width = width + "px";
        }
        if (rect.height !== height) {
            resized = true;
            rect.height = height;
            style.height = height + "px";
        }
        if (resized) {
            phosphor_messaging_1.sendMessage(widget, new phosphor_widget_1.ResizeMessage(width, height));
        }
    }
    SplitLayoutPrivate.setGeometry = setGeometry;
    /**
     * Set the layout geometry of a split handle.
     */
    function setHandleGeo(handle, left, top, width, height) {
        var style = handle.style;
        style.top = top + "px";
        style.left = left + "px";
        style.width = width + "px";
        style.height = height + "px";
    }
    SplitLayoutPrivate.setHandleGeo = setHandleGeo;
    /**
     * Compute the average size of the given box sizers.
     */
    function averageSize(sizers) {
        if (sizers.length === 0)
            return 0;
        return sizers.reduce(function (v, s) { return v + s.size; }, 0) / sizers.length;
    }
    SplitLayoutPrivate.averageSize = averageSize;
    /**
     * Normalize an array of positive values.
     */
    function normalize(values) {
        var n = values.length;
        if (n === 0) {
            return [];
        }
        var sum = 0;
        for (var i = 0; i < n; ++i) {
            sum += values[i];
        }
        var result = new Array(n);
        if (sum === 0) {
            for (var i = 0; i < n; ++i) {
                result[i] = 1 / n;
            }
        }
        else {
            for (var i = 0; i < n; ++i) {
                result[i] = values[i] / sum;
            }
        }
        return result;
    }
    SplitLayoutPrivate.normalize = normalize;
    /**
     * Grow a sizer to the right by a positive delta and adjust neighbors.
     */
    function growSizer(sizers, index, delta) {
        var growLimit = 0;
        for (var i = 0; i <= index; ++i) {
            var sizer = sizers[i];
            growLimit += sizer.maxSize - sizer.size;
        }
        var shrinkLimit = 0;
        for (var i = index + 1, n = sizers.length; i < n; ++i) {
            var sizer = sizers[i];
            shrinkLimit += sizer.size - sizer.minSize;
        }
        delta = Math.min(delta, growLimit, shrinkLimit);
        var grow = delta;
        for (var i = index; i >= 0 && grow > 0; --i) {
            var sizer = sizers[i];
            var limit = sizer.maxSize - sizer.size;
            if (limit >= grow) {
                sizer.sizeHint = sizer.size + grow;
                grow = 0;
            }
            else {
                sizer.sizeHint = sizer.size + limit;
                grow -= limit;
            }
        }
        var shrink = delta;
        for (var i = index + 1, n = sizers.length; i < n && shrink > 0; ++i) {
            var sizer = sizers[i];
            var limit = sizer.size - sizer.minSize;
            if (limit >= shrink) {
                sizer.sizeHint = sizer.size - shrink;
                shrink = 0;
            }
            else {
                sizer.sizeHint = sizer.size - limit;
                shrink -= limit;
            }
        }
    }
    SplitLayoutPrivate.growSizer = growSizer;
    /**
     * Shrink a sizer to the left by a positive delta and adjust neighbors.
     */
    function shrinkSizer(sizers, index, delta) {
        var growLimit = 0;
        for (var i = index + 1, n = sizers.length; i < n; ++i) {
            var sizer = sizers[i];
            growLimit += sizer.maxSize - sizer.size;
        }
        var shrinkLimit = 0;
        for (var i = 0; i <= index; ++i) {
            var sizer = sizers[i];
            shrinkLimit += sizer.size - sizer.minSize;
        }
        delta = Math.min(delta, growLimit, shrinkLimit);
        var grow = delta;
        for (var i = index + 1, n = sizers.length; i < n && grow > 0; ++i) {
            var sizer = sizers[i];
            var limit = sizer.maxSize - sizer.size;
            if (limit >= grow) {
                sizer.sizeHint = sizer.size + grow;
                grow = 0;
            }
            else {
                sizer.sizeHint = sizer.size + limit;
                grow -= limit;
            }
        }
        var shrink = delta;
        for (var i = index; i >= 0 && shrink > 0; --i) {
            var sizer = sizers[i];
            var limit = sizer.size - sizer.minSize;
            if (limit >= shrink) {
                sizer.sizeHint = sizer.size - shrink;
                shrink = 0;
            }
            else {
                sizer.sizeHint = sizer.size - limit;
                shrink -= limit;
            }
        }
    }
    SplitLayoutPrivate.shrinkSizer = shrinkSizer;
    /**
     * A property descriptor for a widget offset rect.
     */
    var rectProperty = new phosphor_properties_1.Property({
        name: 'rect',
        create: function () { return ({ top: NaN, left: NaN, width: NaN, height: NaN }); },
    });
    /**
     * The change handler for the attached child properties.
     */
    function onChildPropertyChanged(child) {
        var parent = child.parent;
        var layout = parent && parent.layout;
        if (layout instanceof SplitLayout)
            parent.fit();
    }
})(SplitLayoutPrivate || (SplitLayoutPrivate = {}));
